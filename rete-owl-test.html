<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rete.js OWL Plugin - Test Page</title>

    <!-- OWL Framework -->
    <script src="https://cdn.jsdelivr.net/npm/@odoo/owl@2.2.2/dist/owl.iife.js"></script>

    <!-- Rete.js Core -->
    <script src="https://cdn.jsdelivr.net/npm/rete@2.0.3/rete.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/rete-area-plugin@2.0.5/rete-area-plugin.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/rete-connection-plugin@2.0.2/rete-connection-plugin.min.js"></script>

    <!-- Plugin Styles -->
    <link rel="stylesheet" href="rete-owl-plugin/styles.css" />

    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: #0a0a14;
        color: #e0e0e0;
        min-height: 100vh;
      }
      .header {
        padding: 16px 24px;
        background: #1e1e2e;
        border-bottom: 1px solid #3a3a4a;
      }
      .header h1 {
        font-size: 18px;
        font-weight: 600;
      }
      .header p {
        font-size: 13px;
        color: #a0a0a0;
        margin-top: 4px;
      }

      #rete-container {
        width: 100%;
        height: calc(100vh - 80px);
      }

      .test-status {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: #1e1e2e;
        border: 1px solid #3a3a4a;
        border-radius: 8px;
        padding: 12px 16px;
        font-size: 12px;
        z-index: 1000;
      }
      .test-status.success {
        border-color: #4caf50;
      }
      .test-status.error {
        border-color: #ff5252;
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1>Rete.js OWL Plugin Test</h1>
      <p>Testing OWL components for node rendering</p>
    </div>

    <div id="rete-container"></div>
    <div id="test-status" class="test-status">Initializing...</div>

    <script type="module">
      const { Component, xml, mount, reactive } = owl;

      // Since we can't use ES modules directly in browser without build,
      // we'll inline the critical parts for testing

      // ============================================
      // INLINE RENDERER (from renderer.js)
      // ============================================
      function createOwlRenderer() {
        const instances = new Map();

        return {
          get(element) {
            return instances.get(element);
          },
          mount(element, OwlComponent, props, onRendered) {
            const reactiveProps = reactive({ ...props });
            const component = mount(OwlComponent, element, {
              props: reactiveProps,
            });

            const instance = {
              component,
              props: reactiveProps,
              updateProps(newProps) {
                Object.assign(this.props, newProps);
              },
            };

            instances.set(element, instance);
            if (onRendered) Promise.resolve().then(onRendered);
            return instance;
          },
          update(instance, payload) {
            if (instance?.props) {
              instance.updateProps(payload);
            }
          },
          unmount(element) {
            const instance = instances.get(element);
            if (instance) {
              try {
                instance.component.destroy();
              } catch (e) {}
              instances.delete(element);
              element.innerHTML = "";
            }
          },
          clear() {
            for (const [el] of instances) this.unmount(el);
          },
        };
      }

      // ============================================
      // INLINE OWL SOCKET COMPONENT
      // ============================================
      class OwlSocket extends Component {
        static template = xml`
                <div class="rete-socket" 
                     t-att-class="socketClasses"
                     t-att-title="props.data.name">
                </div>
            `;
        static props = { data: Object };

        get socketClasses() {
          const type = (this.props.data?.name || "").toLowerCase();
          return {
            "socket-data": type === "data",
            "socket-error": type === "error",
          };
        }
      }

      // ============================================
      // INLINE OWL NODE COMPONENT
      // ============================================
      class OwlNode extends Component {
        static template = xml`
                <div class="rete-node" 
                     t-att-class="nodeClasses"
                     t-att-data-node-id="props.data.id">
                    <div class="node-title">
                        <t t-esc="props.data.label"/>
                    </div>
                    
                    <div class="node-outputs" t-if="hasOutputs">
                        <t t-foreach="outputEntries" t-as="entry" t-key="entry[0]">
                            <div class="output" t-att-data-output-key="entry[0]">
                                <span class="output-label"><t t-esc="entry[1].label || entry[0]"/></span>
                                <div class="output-socket" t-att-data-output-id="entry[0]">
                                    <OwlSocket data="entry[1].socket"/>
                                </div>
                            </div>
                        </t>
                    </div>
                    
                    <div class="node-inputs" t-if="hasInputs">
                        <t t-foreach="inputEntries" t-as="entry" t-key="entry[0]">
                            <div class="input" t-att-data-input-key="entry[0]">
                                <div class="input-socket" t-att-data-input-id="entry[0]">
                                    <OwlSocket data="entry[1].socket"/>
                                </div>
                                <span class="input-label"><t t-esc="entry[1].label || entry[0]"/></span>
                            </div>
                        </t>
                    </div>
                </div>
            `;

        static components = { OwlSocket };
        static props = {
          data: Object,
          emit: { type: Function, optional: true },
        };

        get nodeClasses() {
          return {
            selected: this.props.data?.selected,
            [`node-${this.props.data?.nodeType || "default"}`]: true,
          };
        }

        get hasInputs() {
          return this.inputEntries.length > 0;
        }
        get hasOutputs() {
          return this.outputEntries.length > 0;
        }

        get inputEntries() {
          return this.getEntries(this.props.data?.inputs);
        }
        get outputEntries() {
          return this.getEntries(this.props.data?.outputs);
        }

        getEntries(obj) {
          if (!obj) return [];
          if (obj instanceof Map) return Array.from(obj.entries());
          return Object.entries(obj);
        }
      }

      // ============================================
      // OWL PLUGIN CLASS
      // ============================================
      class OwlPlugin {
        constructor() {
          this.name = "owl-render";
          this.renderer = createOwlRenderer();
          this.presets = [];
          this.owners = new WeakMap();
          this.parentScope = null;
        }

        setParent(scope) {
          this.parentScope = scope;
          this.presets.forEach((p) => p.attach?.(this));
          scope.addPipe?.((ctx) => this._handlePipe(ctx));
        }

        getParentScope() {
          return this.parentScope;
        }

        _handlePipe(context) {
          if (!context?.type) return context;

          if (context.type === "unmount") {
            this.owners.delete(context.data.element);
            this.renderer.unmount(context.data.element);
          } else if (context.type === "render") {
            if (context.data.filled) return context;
            if (this._handleRender(context.data.element, context)) {
              return { ...context, data: { ...context.data, filled: true } };
            }
          }
          return context;
        }

        _handleRender(element, context) {
          const existing = this.renderer.get(element);

          if (existing) {
            for (const preset of this.presets) {
              if (this.owners.get(element) !== preset) continue;
              const result = preset.update(context, this);
              if (result) this.renderer.update(existing, result);
            }
            return true;
          }

          for (const preset of this.presets) {
            const result = preset.render(context, this);
            if (!result) continue;

            this.renderer.mount(element, result.component, result.props, () => {
              this.parentScope?.emit?.({
                type: "rendered",
                data: context.data,
              });
            });
            this.owners.set(element, preset);
            return true;
          }
          return false;
        }

        addPreset(preset) {
          if (preset.attach && this.parentScope) preset.attach(this);
          this.presets.push(preset);
        }
      }

      // ============================================
      // CLASSIC PRESET
      // ============================================
      function setupClassicPreset() {
        return {
          attach(plugin) {},
          render(context, plugin) {
            const { type, payload } = context.data;
            const emit = plugin
              .getParentScope()
              ?.emit?.bind(plugin.getParentScope());

            if (type === "node") {
              return { component: OwlNode, props: { data: payload, emit } };
            }
            return null;
          },
          update(context, plugin) {
            const { type, payload } = context.data;
            const emit = plugin
              .getParentScope()
              ?.emit?.bind(plugin.getParentScope());

            if (type === "node") {
              return { data: payload, emit };
            }
            return { data: payload };
          },
        };
      }

      // ============================================
      // TEST SETUP
      // ============================================
      const statusEl = document.getElementById("test-status");

      async function init() {
        try {
          statusEl.textContent = "Creating editor...";

          const { NodeEditor, ClassicPreset } = Rete;
          const { AreaPlugin, AreaExtensions } = ReteAreaPlugin;
          const { ConnectionPlugin, Presets: ConnectionPresets } =
            ReteConnectionPlugin;

          // Create editor
          const container = document.getElementById("rete-container");
          const editor = new NodeEditor();

          // Setup Area Plugin
          const area = new AreaPlugin(container);

          // Setup Connection Plugin
          const connection = new ConnectionPlugin();
          connection.addPreset(ConnectionPresets.classic.setup());

          // Setup OWL Plugin
          const owlPlugin = new OwlPlugin();
          owlPlugin.addPreset(setupClassicPreset());

          // Wire plugins
          editor.use(area);
          area.use(connection);
          area.use(owlPlugin);

          statusEl.textContent = "Creating test nodes...";

          // Create test nodes
          const socket = new ClassicPreset.Socket("Data");

          class TestNode extends ClassicPreset.Node {
            constructor(name) {
              super(name);
              this.nodeType = "http";
              this.addInput("input", new ClassicPreset.Input(socket, "Input"));
              this.addOutput(
                "output",
                new ClassicPreset.Output(socket, "Output")
              );
            }
          }

          const node1 = new TestNode("HTTP Request");
          const node2 = new TestNode("Data Mapping");

          await editor.addNode(node1);
          await editor.addNode(node2);

          await area.translate(node1.id, { x: 100, y: 100 });
          await area.translate(node2.id, { x: 400, y: 200 });

          // Create connection
          await editor.addConnection(
            new ClassicPreset.Connection(node1, "output", node2, "input")
          );

          // Zoom to fit
          AreaExtensions.zoomAt(area, editor.getNodes());

          statusEl.textContent =
            "✓ OWL Plugin working! Nodes rendered successfully.";
          statusEl.classList.add("success");
        } catch (error) {
          console.error("Test failed:", error);
          statusEl.textContent = `✗ Error: ${error.message}`;
          statusEl.classList.add("error");
        }
      }

      init();
    </script>
  </body>
</html>
